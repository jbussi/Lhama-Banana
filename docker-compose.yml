version: '3.8'

# =====================================================
# REDE E VOLUMES
# =====================================================
networks:
  lhama_banana_network:
    driver: bridge
    name: lhama_banana_network
    ipam:
      config:
        - subnet: 172.20.0.0/16

volumes:
  # PostgreSQL
  postgres_data:
    driver: local
    name: lhama_banana_postgres_data
  postgres_backups:
    driver: local
    name: lhama_banana_postgres_backups
  
  # Flask
  flask_logs:
    driver: local
    name: lhama_banana_flask_logs
  flask_cache:
    driver: local
    name: lhama_banana_flask_cache
  
  # Strapi
  strapi_data:
    driver: local
    name: lhama_banana_strapi_data
  strapi_uploads:
    driver: local
    name: lhama_banana_strapi_uploads
  strapi_cache:
    driver: local
    name: lhama_banana_strapi_cache
  
  # Nginx
  nginx_logs:
    driver: local
    name: lhama_banana_nginx_logs
  nginx_cache:
    driver: local
    name: lhama_banana_nginx_cache
  
  # Certbot
  certbot_www:
    driver: local
    name: lhama_banana_certbot_www
  certbot_conf:
    driver: local
    name: lhama_banana_certbot_conf

services:
  # =====================================================
  # PostgreSQL Database
  # =====================================================
  postgres:
    image: postgres:16.11-alpine
    container_name: lhama_banana_postgres
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${DB_USER:-postgres}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-far111111}
      POSTGRES_DB: ${DB_NAME:-sistema_usuarios}
      PGDATA: /var/lib/postgresql/data/pgdata
      # Configurações de performance
      POSTGRES_INITDB_ARGS: "-E UTF8 --locale=pt_BR.UTF-8"
      # Otimizações de memória
      shared_buffers: 256MB
      effective_cache_size: 1GB
      maintenance_work_mem: 128MB
      checkpoint_completion_target: 0.9
      wal_buffers: 16MB
      default_statistics_target: 100
      random_page_cost: 1.1
      effective_io_concurrency: 200
      work_mem: 4MB
      min_wal_size: 1GB
      max_wal_size: 4GB
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - postgres_backups:/backups
      # Script de inicialização com schema seguro
      - ./db/docker/init:/docker-entrypoint-initdb.d:ro
      # Bind mount apenas para desenvolvimento (descomente se necessário)
      # - ./db/schema.sql:/docker-entrypoint-initdb.d/99-schema.sql:ro
    networks:
      - lhama_banana_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-postgres} -d ${DB_NAME:-sistema_usuarios} && psql -U ${DB_USER:-postgres} -d ${DB_NAME:-sistema_usuarios} -c 'SELECT 1'"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    # Backup automático via cron (container separado)
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
        labels: "service=postgres,database=postgresql"
    # Configurações de segurança
    command:
      - postgres
      - -c
      - max_connections=200
      - -c
      - shared_buffers=256MB
      - -c
      - effective_cache_size=1GB
      - -c
      - maintenance_work_mem=128MB
      - -c
      - checkpoint_completion_target=0.9
      - -c
      - wal_buffers=16MB
      - -c
      - default_statistics_target=100
      - -c
      - random_page_cost=1.1
      - -c
      - effective_io_concurrency=200
      - -c
      - work_mem=4MB
      - -c
      - min_wal_size=1GB
      - -c
      - max_wal_size=4GB
      - -c
      - log_statement=all
      - -c
      - log_duration=on
      - -c
      - "log_line_prefix='%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '"

  # =====================================================
  # PostgreSQL Backup (Cron)
  # =====================================================
  postgres_backup:
    image: postgres:16.11-alpine
    container_name: lhama_banana_postgres_backup
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${DB_USER:-postgres}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-far111111}
      POSTGRES_DB: ${DB_NAME:-sistema_usuarios}
      PGHOST: postgres
      PGPORT: 5432
      BACKUP_SCHEDULE: ${BACKUP_SCHEDULE:-0 2 * * *}  # Diário às 2h
      BACKUP_RETENTION_DAYS: ${BACKUP_RETENTION_DAYS:-7}
    volumes:
      - postgres_backups:/backups
      - ./scripts/backup-postgres.sh:/backup-postgres.sh:ro
    networks:
      - lhama_banana_network
    depends_on:
      postgres:
        condition: service_healthy
    entrypoint: ["/bin/sh", "-c"]
    command:
      - |
        chmod +x /backup-postgres.sh
        # Instalar cron e dependências
        apk add --no-cache dcron
        # Configurar cron
        echo "$${BACKUP_SCHEDULE} /backup-postgres.sh" > /etc/crontabs/root
        # Iniciar cron em foreground
        crond -f -l 2
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
        labels: "service=postgres_backup"

  # =====================================================
  # Flask Application
  # =====================================================
  flask:
    build:
      context: .
      dockerfile: Dockerfile
      args:
        PYTHON_VERSION: "3.11.7"
        GUNICORN_VERSION: "21.2.0"
    image: lhama_banana_flask:latest
    container_name: lhama_banana_flask
    restart: unless-stopped
    environment:
      # Database
      DB_HOST: postgres
      DB_NAME: ${DB_NAME:-sistema_usuarios}
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-far111111}
      DB_PORT: 5432
      
      # Flask
      FLASK_ENV: ${FLASK_ENV:-production}
      FLASK_DEBUG: ${FLASK_DEBUG:-0}
      SECRET_KEY: ${SECRET_KEY}
      PYTHONUNBUFFERED: 1
      PYTHONDONTWRITEBYTECODE: 1
      
      # Gunicorn (otimizado)
      USE_GUNICORN: ${USE_GUNICORN:-true}
      GUNICORN_WORKERS: ${GUNICORN_WORKERS:-4}
      GUNICORN_THREADS: ${GUNICORN_THREADS:-2}
      GUNICORN_TIMEOUT: ${GUNICORN_TIMEOUT:-120}
      GUNICORN_GRACEFUL_TIMEOUT: ${GUNICORN_GRACEFUL_TIMEOUT:-30}
      GUNICORN_MAX_REQUESTS: ${GUNICORN_MAX_REQUESTS:-1000}
      GUNICORN_MAX_REQUESTS_JITTER: ${GUNICORN_MAX_REQUESTS_JITTER:-50}
      GUNICORN_WORKER_CLASS: ${GUNICORN_WORKER_CLASS:-sync}
      GUNICORN_BIND: ${GUNICORN_BIND:-0.0.0.0:5000}
      LOG_LEVEL: ${LOG_LEVEL:-info}
      
      # Logs estruturados
      LOG_FORMAT: json
      LOG_JSON_INDENT: 0
      
      # Firebase
      FIREBASE_SERVICE_ACCOUNT_JSON: ${FIREBASE_SERVICE_ACCOUNT_JSON}
      
      # PagBank
      PAGBANK_API_TOKEN: ${PAGBANK_API_TOKEN:-}
      PAGBANK_ENVIRONMENT: ${PAGBANK_ENVIRONMENT:-sandbox}
      PAGBANK_NOTIFICATION_URL: ${PAGBANK_NOTIFICATION_URL}
      PAGBANK_SIMULATION_MODE: ${PAGBANK_SIMULATION_MODE:-true}
      
      # Melhor Envio
      MELHOR_ENVIO_TOKEN: ${MELHOR_ENVIO_TOKEN:-}
      MELHOR_ENVIO_CEP_ORIGEM: ${MELHOR_ENVIO_CEP_ORIGEM:-13219-052}
      
      # Admin
      ADMIN_EMAILS: ${ADMIN_EMAILS}
      
      # Bling
      BLING_CLIENT_ID: ${BLING_CLIENT_ID:-}
      BLING_CLIENT_SECRET: ${BLING_CLIENT_SECRET:-}
      BLING_REDIRECT_URI: ${BLING_REDIRECT_URI:-}
      NGROK_URL: ${NGROK_URL}
      BLING_WEBHOOK_URL: ${BLING_WEBHOOK_URL:-}
      
      # Strapi
      STRAPI_URL: http://strapi:1337
      STRAPI_ENABLED: ${STRAPI_ENABLED:-true}
    volumes:
      # Logs persistentes
      - flask_logs:/app/logs
      # Cache de dependências
      - flask_cache:/root/.cache/pip
      # Configurações (read-only)
      - ./plataform_config:/app/plataform_config:ro
      # DEV: bind-mount apenas para desenvolvimento (descomente se necessário)
      # - ./blueprints:/app/blueprints
      # - ./templates:/app/templates
      # Key.json (se necessário, descomente e ajuste o caminho)
      # - ./key.json:/app/key.json:ro
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - lhama_banana_network
    healthcheck:
      test: ["CMD-SHELL", "python -c 'import socket; s=socket.socket(); s.settimeout(2); result = s.connect_ex((\"localhost\", 5000)); s.close(); exit(0 if result == 0 else 1)' || curl -f http://localhost:5000/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "5"
        labels: "service=flask,application=flask"
    # Limites de recursos
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M

  # =====================================================
  # Strapi Admin Panel
  # =====================================================
  strapi:
    build:
      context: ./strapi-admin
      dockerfile: Dockerfile
      args:
        NODE_VERSION: "20.11.1"
        STRAPI_VERSION: "5.33.1"
    image: lhama_banana_strapi:latest
    container_name: lhama_banana_strapi
    restart: unless-stopped
    environment:
      # Node heap (evitar "JavaScript heap out of memory")
      NODE_OPTIONS: "--max-old-space-size=2048"
      # Database
      DATABASE_CLIENT: postgres
      DATABASE_HOST: postgres
      DATABASE_PORT: 5432
      DATABASE_NAME: ${DB_NAME:-sistema_usuarios}
      DATABASE_USERNAME: ${DB_USER:-postgres}
      DATABASE_PASSWORD: ${DB_PASSWORD:-far111111}
      DATABASE_SCHEMA: public
      DATABASE_SSL: "false"
      
      # Strapi - MIGRAÇÕES DESABILITADAS
      NODE_ENV: ${NODE_ENV:-production}
      HOST: 0.0.0.0
      PORT: 1337
      APP_KEYS: ${STRAPI_APP_KEYS:-app-key-1,app-key-2,app-key-3,app-key-4}
      API_TOKEN_SALT: ${STRAPI_API_TOKEN_SALT:-api-token-salt-12345}
      ADMIN_JWT_SECRET: ${STRAPI_ADMIN_JWT_SECRET:-admin-jwt-secret-12345}
      TRANSFER_TOKEN_SALT: ${STRAPI_TRANSFER_TOKEN_SALT:-transfer-token-salt-12345}
      JWT_SECRET: ${STRAPI_JWT_SECRET:-jwt-secret-12345}
      
      # CRÍTICO: Desabilitar migrações automáticas
      AUTO_MIGRATE: ${AUTO_MIGRATE:-false}
      AUTO_RELOAD: ${AUTO_RELOAD:-false}
      
      # Public URL
      PUBLIC_URL: ${STRAPI_PUBLIC_URL:-http://localhost:1337}
      
      # Flags
      FLAG_NPS: ${FLAG_NPS:-false}
      FLAG_PROMOTE_EE: ${FLAG_PROMOTE_EE:-false}
      FLAG_PROMOTE_TRIAL: ${FLAG_PROMOTE_TRIAL:-false}
      FLAG_SHOW_TRIAL: ${FLAG_SHOW_TRIAL:-false}
    volumes:
      - strapi_data:/app/.tmp
      - strapi_uploads:/app/public/uploads
      - strapi_cache:/app/.cache
      # Node modules como volume nomeado (não bind mount)
      - /app/node_modules
      # DEV: bind-mount do código fonte apenas em desenvolvimento (descomente se necessário)
      # - ./strapi-admin/src:/app/src
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - lhama_banana_network
    healthcheck:
      test: ["CMD-SHELL", "wget --quiet --tries=1 --spider http://localhost:1337/_health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 90s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "5"
        labels: "service=strapi,cms=strapi"
    # Limites de recursos
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M

  # =====================================================
  # Nginx Reverse Proxy
  # =====================================================
  nginx:
    build:
      context: .
      dockerfile: nginx/Dockerfile
      args:
        NGINX_VERSION: "1.25.5"
    image: lhama_banana_nginx:latest
    container_name: lhama_banana_nginx
    restart: unless-stopped
    ports:
      - "${NGINX_HTTP_PORT:-80}:80"
      - "${NGINX_HTTPS_PORT:-443}:443"
    volumes:
      # Logs formatados
      - nginx_logs:/var/log/nginx
      # Cache
      - nginx_cache:/var/cache/nginx
      # Certificados SSL (compartilhado com Certbot)
      - certbot_www:/var/www/certbot:ro
      - certbot_conf:/etc/letsencrypt:ro
      # Configuração (read-only)
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/nginx-ssl.conf.template:/etc/nginx/templates/nginx-ssl.conf.template:ro
    depends_on:
      - flask
      - strapi
    networks:
      - lhama_banana_network
    healthcheck:
      test: ["CMD-SHELL", "wget --quiet --tries=1 --spider http://localhost/health || exit 1"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "5"
        labels: "service=nginx,proxy=nginx"
    # Headers de segurança e rate limiting configurados no nginx.conf

  # =====================================================
  # Certbot (Let's Encrypt SSL Certificates)
  # =====================================================
  certbot:
    image: certbot/certbot:v2.9.0
    container_name: lhama_banana_certbot
    restart: unless-stopped
    volumes:
      - certbot_www:/var/www/certbot
      - certbot_conf:/etc/letsencrypt
    networks:
      - lhama_banana_network
    environment:
      - CERTBOT_EMAIL=${CERTBOT_EMAIL}
      - CERTBOT_DOMAIN=${CERTBOT_DOMAIN:-}
      - CERTBOT_STAGING=${CERTBOT_STAGING:-false}
    # Renew automático a cada 12 horas
    entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew --quiet --deploy-hook \"nginx -s reload\"; sleep 12h & wait $${!}; done;'"
    depends_on:
      - nginx
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
        labels: "service=certbot,ssl=certbot"
